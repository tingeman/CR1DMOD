function out = temfwd(varargin);

% out = temfwd(config, layers, cparams);
% 
% temfwd.m is part of the CR1Dmod forward modeling package, and contains
% the code used to calculate the response of a central-loop configuration
% over a 1D layered half space.
%
% Input:
% config :    structure defining the configuation (generated by cr1dmod) 
% layers :    structure defining layer-parameters (generated by cr1dmod)
% cparams:    structure defining calculation options (generated by compute)
%
% Output:
% out:        vector of calculated impedances
%
%
% EXAMPLE of usage: (copy to command window, without leading "% ")
%
% Calculate the response from a central loop sounding. The transmitter loop
% has a radius of 10 m, the receiver loop an effective area of 100 sqm.
% The ground is two-layer model with the parameters rho_1 = 100 Ohm.m, 
% h1 = 10 m, rho_2 = 30 Ohm.m.
% Layer 1 has a dispersive resistivity of the cole-cole type.
%
% % Setup input structures:
%
% config.type = 'TEM Central Loop'  % TEM Central loop configuration
% config.TxR  = 7.13                % Transmitter loop radius (m)
% %  If using a square transmitter loop, one can specify the side length, TxS,
% %  instead, and the function will calculate the radius of the equivalent 
% %  circular loop.
% %  config.TxS = 40                   % Square transmitter loop side length (m)
% config.RxA  = 100                 % Receiver loop effective area (sqm)
% 
% layers(1).depth_to_top = 0;       % Layer 1 depth-to-top of layer
% layers(1).thickness    = 10;      % Layer 1 thickness
% layers(1).rho          = 50;     % Layer 1 resistivity
% layers(1).m            = 0.8;     % Layer 1 cole-cole chargeability
% layers(1).tau          = 1e-5;    % Layer 1 cole-cole time constant
% layers(1).c            = 0.3;     % Layer 1 cole-cole exponent
% layers(1).eps_r        = 1;       % Layer 1 relative permittivity
% layers(1).mu           = 0;       % Layer 1 magnetic permeability
% layers(2).depth_to_top = 10;      % Layer 2 depth-to-top of layer
% layers(2).thickness    = Inf;     % Layer 2 thickness (use Inf for bottom layer)
% layers(2).rho          = 10;      % Layer 2 resistivity
% layers(2).m            = 0;       % Layer 2 cole-cole chargeability
% layers(2).tau          = 0;       % Layer 2 cole-cole time constant
% layers(2).c            = 0;       % Layer 2 cole-cole exponent
% layers(2).eps_r        = 1;       % Layer 2 relative permittivity
% layers(2).mu           = 0;       % Layer 2 magnetic permeability
% 
% cparams.domain    = 'TD'          % Time Domain calculation
% cparams.calc_type = 'Quasi'       % Use quasi-stationary approximation
% cparams.times     = logspace(-6,-3,30) % Specify decay times for which to calculate result
% cparams.waveform  = 'Step function'    % Only option at the moment! 
% cparams.hank_type = 'FHT'         % Choose Fast Hankel Transform using digital filters for calculating FD response
% cparams.FHT_err = 1.0000e-08      % Tolerance of Fast Sine Transform
% cparams.FDspline = 1              % Use spline to approximate frequency domain response (0=no, 1=yes)
% cparams.FDsp_NDEC = 10            % Number of frequencies to calculate for spline interpolation
% cparams.FDsp_Bmin = 1.0000e-04    % Smallest frequency (induction number) to calculate
% cparams.FDsp_Bmax = 1000          % Largest frequency (induction number) to calculate
% cparams.FtoTtype  = 'FST'         % Choose Fast Sine Transform using digital filters
% cparams.FST_err   = 1.0000e-08    % Tolerance of Fast Sine Transform
% cparams.showFDsp  = 1             % plot underlying freq. domain calculations (0=no, 1=yes)
% 
% % The following is only needed for Numerical Hankel Transform integration:
% 
% cparams.Seg_tol = 1e-6;     % Tolerance on each segment of the integration
% cparams.NHT_tol = 1e-5;     % Tolerance on the sum of the series
% cparams.Max_seg = 100;      % Maximum number of segments to sum
% 
% % Run forward calculation:
% 
% result = temfwd(config,layers,cparams);
% plotdat('tem', result, config, cparams)
%
% % END OF EXAMPLE
%
% The file contains an option to calculate the response of a square loop
% transmitter loop as measured by a vertical magnetic dipole receiver.
% So far only dipole location in the center of the transmitter loop is 
% allowed. The Sq-dip option is not included in the GUI.
%
% Written by:
% Thomas Ingeman-Nielsen
% The Arctic Technology Center, BYG
% Technical University of Denmark
% Email: tin@byg.dtu.dk

cpu_t=cputime;

disp('Routine: TEMfwd');

global FDkern

if ( nargin < 3 )
    disp('A call to temfwd must provide three input arguments!');
    return
end

% Set up structures of parameters...
ok = 0;
if ( isstruct(varargin{1})         )
    config = varargin{1};
    if ( isstruct(varargin{2})     )
        layers = varargin{2};
        if ( isstruct(varargin{3}) )
            cparams = varargin{3};                    
            ok = 1;
        end
    end
end
if ~ok
    disp('Non-structure inputs have not been implemented yet!');
    return
end

config.Txz = 0; % assume Tx loop is on the ground (only option implemented)
config.Rxz = 0; % assume Rx loop is on the ground (only option implemented)
% The function is not capable of calculating with heights!

if ( ~isfield(config,'TEMtype') )  || ...
    ( isempty(config.TEMtype)   )
    config.TEMtype = 'circ-dip';       % Geometry assumption [circ-dip, sq-dip, sq-sq]
end

if ( ~isfield(config,'TxR')     )  || ...
        ( isempty(config.TxR)   )
    if ( ~isfield(config,'TxS')     )  || ...
            ( isempty(config.TxS)   )
        config.TxS = 40;
        disp('TxS set to 40m');
        beep;
    end		
		
    config.TxR = sqrt(config.TxS.^2./pi);       % Tx equivalent circular loop radius used for normalization
end

% Prepares frequency domain spline or individual calculations by either
% calculating a spline function and returning a handle to a function that
% evaluates the spline, or returning a handle to the function that calculates
% the frequency domain response.
TEM_handle = Hz_TEM_driver(config, layers, cparams);

disp('Finished the frequency domain computations...');

switch  cparams.domain
    case {'TD'}
        if ( cparams.FDspline      )  && ...
                ( cparams.showFDsp )
            h1 = figure;
            semilogx(sqrt(FDkern.b), FDkern.kern(2:end-1), '-xb',       ...
                'markersize', 4);
            h2 = legend('Spline');
        end
        
        T = 2.*cparams.times./(1./layers(1).rho.*4.*pi.*1e-7.*          ...
            config.TxR.^2); % Define normalized time
        
        hw = waitbar(0,'Please wait...');
        for k=1:max(size(T))
            switch cparams.FtoTtype
                case {'FST'}
                    out(k) = -FCST('SI4', T(k), -1, 0, 0,...
                        cparams.FST_err, TEM_handle, config,...
                        layers, cparams);
                case {'NST'}                
                    out(k) = -NJCST('SIN', TEM_handle, T(k),...
                        cparams.Seg_tol, cparams.NST_tol,...
                        cparams.Max_seg, config, layers, cparams);
                case {'NCT'}
                    out(k) = NJCST('COS', TEM_handle, T(k),...
                        cparams.Seg_tol, cparams.NCT_tol,...
                        cparams.Max_seg, config, layers, cparams);
            end % switch
            waitbar(k/(length(T)),hw);
        end % k
        close(hw);
        
        switch config.TEMtype
            case {'circ-dip'}
                out = out.*2./pi.*config.RxA./                          ...
                    (1./layers(1).rho.*config.TxR.^3);
            case {'sq-dip'}
                out = out.*8.*config.Rxn.*config.RxR.^2./               ...
                    (config.TxR.^2.*1./layers(1).rho);
            case {'sq-sq'}
                % not implemented yet
        end        
        
        if ( cparams.FDspline      )  && ...
                ( cparams.showFDsp )  && ...
                ( ishandle(h1)     )
            figure(h1);
            hold on;
            est = unique(FDkern.estimate);
            semilogx(sqrt(est), ppval(FDkern,est), 'xr', 'markersize', 4);
            delete(h2);
            legend({'Spline'; 'Evaluations'});
            xlimits = xlim;
            omega = 2.*xlimits.^2./...
                (1./layers(1).rho.*4e-7.*pi.*config.TxR.^2);
            disp(omega);
            
        end
            
    case {'FD'}
        b = cparams.freq.*2.*pi./...
            layers(1).rho.*4e-7.*pi.*config.TxR.^2./2;
        out = feval(TEM_handle, b, config, layers, cparams);
end    

disp(['Time spent: ' num2str(cputime-cpu_t) ' s']);

% -------------------------------------------------------------------------
function funchan = Hz_TEM_driver(config, layers, cparams);

global FDkern estimate

if ( ~cparams.FDspline )     % In the case no spline interpolation is wanted
                             %     return handle to FD calculation routine
    estimate = [];                             
    switch cparams.domain
        case {'TD'}
            switch cparams.FtoTtype
                case {'NST','FST'}
                    switch config.TEMtype
                        case {'circ-dip'}
                            funchan = @imHz_CircDip;
                        case {'sq-dip'}
                            funchan = @imHz_SqDip;
                        case {'sq-sq'}
                            % not implemented yet
                    end                    
                case {'NCT','FCT'}
                    switch config.TEMtype
                        case {'circ-dip'}
                            funchan = @reHz_CircDip;
                        case {'sq-dip'}
                            funchan = @reHz_SqDip;
                        case {'sq-sq'}
                            % not implemented yet
                    end                  
            end % switch
        case {'FD'}
            switch config.TEMtype
                case {'circ-dip'}
                    funchan = @Hz_CircDip;
                case {'sq-dip'}
                    funchan = @Hz_SqDip;
                case {'sq-sq'}
                    % not implemented yet
            end
    end % switch
        
else                         % Else set up the spline function         
    if ( ~isfield(cparams,'FDsp_NDEC')   )  ||                          ...
            ( isempty(cparams.FDsp_NDEC) )
        cparams.FDsp_NDEC = 15;
    end
    
    if ( ~isfield(cparams,'FDsp_Bmin')   )  ||                          ...
            ( isempty(cparams.FDsp_Bmin) )
        cparams.FDsp_Bmin = 1e-3;
    end
    
    if ( ~isfield(cparams,'FDsp_Bmax')   )  ||                          ...
            ( isempty(cparams.FDsp_Bmax) )
        cparams.FDsp_Bmax = 1e3;
    end
    
    b = [10.^(2.*([log10(cparams.FDsp_Bmin):                            ...
                1./cparams.FDsp_NDEC:                                   ...
                log10(cparams.FDsp_Bmax)]))];
    
    switch config.TEMtype
        case {'circ-dip'}
            kern = Hz_CircDip(b, config, layers, cparams);
        case {'sq-dip'}
            kern = Hz_SqDip(b, config, layers, cparams);
        case {'sq-sq'}
            % not implemented yet
    end                    
    
    switch cparams.domain
        case {'TD'}
            switch cparams.FtoTtype
                case {'NST','FST'}
                    % Used for Sine transform
                    b = [0 b];
                    kern = [0 0 imag(kern) 0]; % Make the endslopes of the spline horizontal
                case {'NCT','FCT'}
                    % Used for Cosine transform
                    b = [0 b cparams.FDsp_Bmax.^2.*1e6];
                    kern = [0 1 real(kern) 0 0]; 
            end % switch
            
        case {'FD'}
            kern = [0 kern 0]; % Make the endslopes of the spline horizontal
    end % switch
    
    FDkern = spline(b,kern);
    FDkern.b = b;
    FDkern.kern = kern;
    FDkern.estimate = [];
    
    funchan = @FDspline_eval;
end


% ---------------------------------------------------------------------
function kern = FDspline_eval(b, config, layers, cparams);

global FDkern
kern = ppval(b, FDkern);
FDkern.estimate = [FDkern.estimate b];

% ---------------------------------------------------------------------
function kern = imHz_CircDip(b, config, layers, cparams);

global estimate

kern = imag(Hz_CircDip(b, config, layers, cparams));
estimate = [estimate, [b;kern]];

% ---------------------------------------------------------------------
function kern = imHz_SqDip(b, config, layers, cparams);

global estimate

kern = imag(Hz_SqDip(b, config, layers, cparams));
estimate = [estimate, [b;kern]];


% ---------------------------------------------------------------------
function kern = reHz_CircDip(b, config, layers, cparams);

global estimate

kern = real(Hz_CircDip(b, config, layers, cparams));
estimate = [estimate, [b;kern]];

% ---------------------------------------------------------------------
function kern = reHz_SqDip(b, config, layers, cparams);

global estimate

kern = real(Hz_SqDip(b, config, layers, cparams));
estimate = [estimate, [b;kern]];

% *************************************************************************
% * Code for circular transmitter loop and dipole reciever                *
% *************************************************************************
function [Hz] = Hz_CircDip(b, config, layers, cparams)

% [Hz] = Hz_CircDip(b, config, layers, cparams);
% Calculates the Hz field for the central loop configuration
% at a speciffic frequency.
%
% b:         radius of Transmitter loop
% config :    structure defining the configuation (generated by cr1dmod) 
% layers :    structure defining layer-parameters (generated by cr1dmod)
% cparams:    structure defining calculation options (generated by compute)

mu0 = 4.*pi.*1e-7;
eps0 = 8.85418782.*1e-12;
omega = 2.*b./(1./layers(1).rho.*mu0.*config.TxR.^2); 

if ~all([layers.m]==0)
    sigma =  1./Z_CR(omega, [layers.rho].', [layers.tau].',             ...
        [layers.c].', [layers.m].');
else
    sigma = 1./[layers.rho].'*ones(size(omega));
end

if strcmp(cparams.calc_type,'Quasi')
    % Quasi static Halfspace response assumes also nonmagnetic first layer
    % Here calculated using analytic expression
    % disp('quasi+nonmag')
    TEM_handle = @TEM_kernel_quasi;
    layers(1).mu = 0; % ensures non-magnetic first layer
    z0 = i.*omega.*mu0;
    k0_sq = 0;
    y = sigma; % Permittivity of the ground is neglected
    k_sq = -repmat(z0,length(layers),1).*y;
    Hz = 1./(k_sq(1,:).*config.TxR.^4).*...
        (-3 -(k_sq(1,:).*config.TxR.^2-3.*i.*k_sq(1,:).^0.5.*...
        config.TxR-3).*exp(-i.*k_sq(1,:).^0.5.*config.TxR));
    
elseif layers(1).mu == 0
    % Halfspace response non-magnetic first layer
    % disp('nonmag')
    TEM_handle = @TEM_kernel_nonmag;
    z0 = i.*omega.*mu0;
    y0 = i.*omega.*eps0;
    k0_sq = -z0.*y0;
    z = i.*mu0.*([layers.mu]+1).'*omega;
    y = sigma + i.*eps0.*[layers.eps_r].'*omega;
    k_sq = -z.*y;
    Hz = 1./((k_sq(1,:)-k0_sq).*config.TxR.^4).*(...
        (k0_sq.*config.TxR.^2-3.*i.*k0_sq.^0.5.*config.TxR-3).*...
        exp(-i.*k0_sq.^0.5.*config.TxR) - (k_sq(1,:).*...
        config.TxR.^2-3.*i.*k_sq(1,:).^0.5.*config.TxR-3).*...
        exp(-i.*k_sq(1,:).^0.5.*config.TxR) );
  else
    % disp('full')    
    TEM_handle = @TEM_kernel_full;
    Hz = zeros(size(omega));
end

if length(layers)>1 || (layers(1).mu ~= 0 && ...
        ~strcmp(cparams.calc_type,'Quasi'))
    switch cparams.hank_type
        case 'NHT'
            for k=1:max(size(omega))
                Hz(k) = Hz(k) + ...          % assume Tx is on the ground...
                    NJCST('J1', TEM_handle, config.TxR, cparams.Seg_tol,...
                    cparams.NHT_tol, cparams.Max_seg, config.Txz,...
                    omega(k), [layers.eps_r].'.*eps0,...
                    ([layers.mu].'+1).*mu0, sigma(:,k),...
                    [layers(1:end-1).thickness].')+1;
            end
        case 'FHT'
            for k=1:max(size(omega))
                Hz(k) = Hz(k) + ...          % assume Tx is on the ground...
                    FJCST('J14', config.TxR, -1, 0, 0, ...
                    cparams.FHT_err, TEM_handle, config.Txz, omega(k), ...
                    [layers.eps_r].'.*eps0,...
                    ([layers.mu].'+1).*mu0, sigma(:,k),...
                    [layers(1:end-1).thickness].')+1;
            end
    end
end
Hz = Hz.*(2.*config.TxR.^2); 

% *************************************************************************
% * Code for square transmitter loop and dipole reciever                  *
% *************************************************************************
function [Hz] = Hz_SqDip(b, config, layers, cparams);

% [Hz] = Hz_SqDip(b, config, layers, cparams)
% Calculates the Hz field for the central loop configuration
% at a speciffic frequency.
%
% b:          Equivalent radius of Transmitter loop b = sqrt(TxS^2/pi)
%                     where TxS is the side length of the square loop.
% config :    structure defining the configuation (generated by cr1dmod) 
% layers :    structure defining layer-parameters (generated by cr1dmod)
% cparams:    structure defining calculation options (generated by compute)

mu0 = 4e-7.*pi;
eps0 = 8.85418782.*1e-12;
omega = 2.*b./(1./layers(1).rho.*mu0.*config.TxR.^2);

if ~all([layers.m]==0)
    sigma =  1./Z_CR(omega, [layers.rho].', [layers.tau].',             ...
        [layers.c].', [layers.m].');
else
    sigma = 1./[layers.rho].'*ones(size(omega));
end

TEM_handle = @square_quad;

Txloop = [-config.TxS/2  -config.TxS/2;...
        -config.TxS/2   config.TxS/2;...
        config.TxS/2   config.TxS/2;...
        config.TxS/2  -config.TxS/2;...
        -config.TxS/2  -config.TxS/2];

S = sqrt(sum(diff(Txloop).^2,2));            % Calculate length of each transmitter loop element (side)

%h1 = waitbar(0,'Please wait...');

Hz = zeros(1,length(omega));

% We assume here the central loop configuration in which
% all four sides of a square loop contributes equally.

for k = 1:length(omega)
    %    for m = 1:4              % do calculations for the four sides 
    m = 1;                % This is true only for square loop in central loop config
    Hz(k) = Hz(k) + quad(TEM_handle, 0, S(m), cparams.Quad_tol, [], ...
        Txloop(m:m+1,:), S(m), omega(k),                            ...
        eps0.*[layers.eps_r].',                        ...
        ([layers.mu].'+1).*mu0, sigma,                         ...   % 1./[layers.rho].'
        [layers(1:end-1).thickness].', cparams.FHT_err);
    %    end
    %    titlestr = ['Just did: \omega = ' num2str(round(omega(k)*1000)/1000)];
    %    waitbar(k/length(omega), h1, titlestr);
end

Hz = 4.* Hz;
% close(h1);        

% ---------------------------------------------------------------------        
function term = square_quad(s, dTx, S, omega, eps, mu, sigma, h, FHT_err);

% This function calculates the contribution from a linear wire segment to 
% the vertical magnetic field at a certain location.
% So far only implemented with the Fast Hankel Transform and for the full
% solution

TEM_handle = @TEM_kernel_full;

ds = repmat(diff(dTx)./S,length(s),1)...
    .*repmat(s', 1, 2) + repmat(dTx(1,:),length(s),1);  

r = sqrt(sum(ds.^2,2));
if sum(dTx(:,2))==0  % This is a y-directed integration
    if dTx(1,2)>dTx(2,2)  % negative integration direction
        y = dTx(1,1);
    else
        y = -dTx(1,1);
    end
else                 % This is an x-directed integration
    if dTx(1,1)>dTx(2,1)  % negative integration direction
        y = dTx(1,2);
    else
        y = -dTx(1,2);
    end
end

z = 0; % we assume source and receiver on the ground

for k = 1:length(r)
    term(k) = y./r(k).*(...
        FJCST('J14', r(k), -1, 0, 0, FHT_err, TEM_handle,             ...
        z, omega, eps, mu, sigma, h) + 1/(2.*r(k)^2)); % + r./(2.*(r.^2+z.^2).^(3/2)));
end

term = term./(4.*pi);

% *************************************************************************
% * Kernel functions for circular/square transmitter loop and dipole Rz   *
% *************************************************************************

function kern = TEM_kernel_full(lambda, varargin)

% kern = TEM_kernel_full(lambda, omega, eps, mu, sigma, h)
%
% Kernelfunction:       ((R_TE+1)*lambda/u0)*lambda
%
% This version is for the full solution!

% varargin{1} contains the height of the observation point and is not used
omega = varargin{2};
eps =   varargin{3};
mu =    varargin{4};
sigma = varargin{5};
h =     varargin{6};

lambda_sq = lambda.^2;
z0 = i.*omega.*4.*pi.*1e-7;
y0 = i.*omega.*8.85418782.*1e-12;
k0_sq = -z0.*y0;
u0 = sqrt(lambda_sq-k0_sq);
z = j.*omega.*mu;
y = sigma + i.*eps.*omega;
k_sq = -z.*y;
u = sqrt(repmat(lambda_sq,size(k_sq,1),1)-repmat(k_sq, 1, size(lambda_sq,2)));
Y = u./repmat(z,1,size(lambda,2));
Y0 = u0./z0;

gamma = 0;
if ~isempty(h)
    expuh2 = exp(-2.*u(1:end-1,:).*repmat(h,1,length(lambda)));
    phi = (Y(1:end-1,:)-Y(2:end,:))./(Y(1:end-1,:)+Y(2:end,:)); %  = (Yn-Yn+1)/(Yn+Yn+1)    
    for m = length(h):-1:1
        gamma = expuh2(m,:).*(gamma+phi(m,:))./(gamma.*phi(m,:)+1);
    end
end
phi1 = (Y0-Y(1,:))./(Y0+Y(1,:));            %  as needed in the numerator
phi1mod = 1./(u0 + u(1,:).*z0./z(1,:));     %  as needed in the denominator

kern = (((gamma+1).*phi1mod)./(gamma.*phi1+1).*lambda-1./2).*lambda;   % = (R_TE+1)*lambda^2/u0


%--------------------------------------------------------------------------
function kern = TEM_kernel_nonmag(lambda, varargin)

% kern = TEM_kernel_nonmag(lambda, omega, eps, mu, sigma, h)
%
% Kernelfunction:       ((R_TE+1)*lambda/u0)*lambda
%
% This version is for the nonmagnetic first layer solution!

% varargin{1} contains the height of the observation point and is not used
omega = varargin{2};
eps =   varargin{3};
mu =    varargin{4};
sigma = varargin{5};
h =     varargin{6};

lambda_sq = lambda.^2;
z0 = i.*omega.*4e-7.*pi;
y0 = i.*omega.*8.85418782.*1e-12;
k0_sq = -z0.*y0;
u0 = sqrt(lambda_sq-k0_sq);
z = j.*omega.*mu;
y = sigma + i.*eps.*omega; 
k_sq = -z.*y;
u = sqrt(repmat(lambda_sq,size(k_sq,1),1)-repmat(k_sq, 1, size(lambda_sq,2)));
Y = u./repmat(z,1,length(lambda));
Y0 = u0./z0;

gamma = 0;
if ~isempty(h)
    expuh2 = exp(-2.*u(1:end-1,:).*repmat(h,1,length(lambda)));
    phi = (Y(1:end-1,:)-Y(2:end,:))./(Y(1:end-1,:)+Y(2:end,:)); %  = (Yn-Yn+1)/(Yn+Yn+1)    
    for m = length(h):-1:1
        gamma = expuh2(m,:).*(gamma+phi(m,:))./(gamma.*phi(m,:)+1);
    end
end

kern = ((2.*gamma.*u(1,:)./(gamma.*(k_sq(1,:)-k0_sq)+(u0+u(1,:)).^2)).* ...
    lambda-1./2).*lambda;   


%--------------------------------------------------------------------------
function kern = TEM_kernel_quasi(lambda, varargin)

% kern = TEM_kernel_quasi(lambda, omega, eps, mu, sigma, h)
%
% Kernelfunction:       ((R_TE+1)*lambda/u0)*lambda
%
% This version is for the quasi-static solution! k0=0

% varargin{1} contains the height of the observation point and is not used
omega = varargin{2};
eps =   varargin{3};
mu =    varargin{4};
sigma = varargin{5};
h =     varargin{6};

lambda_sq = lambda.^2;
z0 = i.*omega.*4.*pi.*1e-7;
z = j.*omega.*mu;
y = sigma;  % Permittivity of the ground is neglected
k_sq = -z.*y;
u = sqrt(repmat(lambda_sq,size(k_sq,1),1)-repmat(k_sq, 1, size(lambda_sq,2)));
Y = u./repmat(z,1,size(lambda,2));
Y0 = lambda./z0;

gamma = 0;
if ~isempty(h)
    expuh2 = exp(-2.*u(1:end-1,:).*repmat(h,1,length(lambda)));
    phi = (Y(1:end-1,:)-Y(2:end,:))./(Y(1:end-1,:)+Y(2:end,:)); %  = (Yn-Yn+1)/(Yn+Yn+1)    
    for m = length(h):-1:1
        gamma = expuh2(m,:).*(gamma+phi(m,:))./(gamma.*phi(m,:)+1);
    end
end

phi1 = (Y0-Y(1,:))./(Y0+Y(1,:));    %  as needed in the numerator
phi1mod = (1./z0)./(Y0+Y(1,:));     %  as needed in the denominator

kern = ((2.*gamma.*u(1,:)./(gamma.*k_sq(1,:)+(lambda+u(1,:)).^2)).* ...
    lambda-1./2).*lambda;
